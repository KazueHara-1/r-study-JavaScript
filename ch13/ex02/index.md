## f3()

### 結果と説明

まず、同期的処理の中ではエラーは発生しないためfinally()内のlogCが実行される。
その後非同期処理のlogAが実行される。そしてerrXが発生する。

> 非同期処理を実行しているときは、呼び出し元はコールスタック上には存在しません。このため、非同期処理で何か問題が発生した場合は、例外を呼び出し元にスローすることはできません。

エラーはthen()の中で発生しているが、これは非同期処理となるためエラーを元のプログラムでcatchすることはできない。
そのため、then()の中でエラーが発生し、プログラムは異常終了する。

### 図解

```
logC
wait(0)
|
logA
|
errX
```

## f4()

### 結果と説明

プログラム実行から2秒後にlogAが実行される。引数value=40の状態で次のthenに移る。1秒後にlogBが実行される。その直後にv=40でlog(v)が実行される。

### 図解

```
wait2()
|----|
     logA()
     wait(1000)
     |--|
        logB()
        |
        log(v)  // log(100)
```

## f5()

### 結果と説明

2つめのthenにPromiseを渡しているため、このPromiseはthenに関係なく実行されてしまう。そのため、プログラム実行1秒後にlogBが実行される。logAはf4()と同様に2秒後に実行され、その直後にlog(v)が実行される。この時のvは1つ目のthenが返した40となる。

### 図解

```
wait(1000)
|--|
  logB()
wait2()
|----|
     logA()
        |
        log(v)  // log(40)
```

## f6()

### 結果と説明

> then() 呼び出しのチェーンを記述するとき、1 つの Promise オブジェクトに対して複数のコールバックを登録しているわけではありません。then() メソッドを呼び出すたびに、新しい Promise オブジェクトが返されています

そのため、複数回then()を呼び出したところでコールバックが上書きされることはなく、それぞれpが解決されたのちにそれぞれのコールバックが呼び出される。

### 図解

```
wait1()
|---|
  logA()
   |-|
     wait1()
     |---|
         logB()
         |-|
     wait2()
     |------|
            logC()
```

## f7()

### 結果と説明

解決済みのPromiseのthenを呼び出すと、Promiseのresolveにコールバック関数が設定される。Promiseはすでに解決済みであるので、コールバック関数は設定時に即時実行される。

### 図解

```
wait1()
|---|
  logA()
wait2()
|------|
       logB()
       |
       logC()
```

## f8()

### 結果と説明

1秒後にerrX()によりエラーが返される。次の.then(errY)は実行されず、.catch()が実行され、その中のlog(e.message)が実行される。この時のe.messageはerrXが返したエラーオブジェクトを参照するのでXとなる。その後、finally()の中のlogAが実行される。

### 図解

```
wait1()
|---|
    errX()
    |
    log("X")
    |
    logA()
```

## f9()

### 結果と説明

1秒後に42を返すアロー関数が実行され、errY()が実行される。エラーが返されたのでcatch()内のlog(e.message)が引数Yで実行され、その後logAが実行される。

### 図解

```
wait1()
|---|
    ()=>42
    |
    errY()
    |
    log("Y") // Y
    |
    logA() // A
```

## f10()

### 結果と説明

errYがthenの中で実行されるが、このerrYに対応するcatch句は存在しないためこのエラーはcatchされない。（thenの代に引数であるonRejectedは、その前のアロー関数がErrorを返した際に実行される。）catchは存在しないがエラーを返された後、finally()は実行され、logAが実行される。  
補足：log(e.message)をerrYに対して実行したい場合はf9()のように...then(errY).catch(e=>log(e.message))と書くべきである。

### 図解

```
wait1()
|---|
    ()=>42
    |
    errY() // throw Error
    |
    logA
```

## f11()

### 結果と説明

new Promiseの中でthrowされた例外は.catch()でキャッチされ、logとして出力される。

### 図解

```
wait1()
|---|
    ()=>42
    |
    errY() // throw Error
    |
    logA
```

## f12()

### 結果と説明

setTimeout関数は値を返さないため、setTimeout内でthrowされたとしてもそれはPromiseの中でthrowされたということにはならない（Promiseの外でthrowされたことになる）。そのため発生した例外はキャッチされず、プログラムは終了する。

### 図解

```
wait1()
|---|
    ()=>42
    |
    errY() // throw Error
    |
    logA
```
